package peachtree.options;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import org.json.JSONArray;
import org.json.JSONObject;
//import org.reflections.Reflections;

import peachtree.aln.AlignmentAPI;
import peachtree.aln.colourings.ClustalAminoColouring;
import peachtree.aln.colourings.Colouring;
import peachtree.aln.colourings.JalviewNucleotideColouring;



public class OptionsAPI {
	

	
	static Option canvasWidth  = new NumericalOption("width", "General", "Width of canvas", 1000, 100, 2000);
	static Option canvasHeight  = new NumericalOption("height", "General", "Height of canvas", 700, 100, 2000);
	static Option division  = new NumericalOption("division", "General", "Relative position of the tree/alignment boundary", 0.2, 0, 1);
	static Option colourings;
	
		
	static List<Class<? extends Colouring>> colouringClasses;
	static final long CHUNK_SIZE = 30000;
	static JSONArray graphicalObjects = null;
	
	public static void init() throws Exception {
		
		graphicalObjects = null;
		
		

		
		
		
		
	}
	

	
	
	/**
	 * Prepares the colouring option so that only colour schemes applicable to the current alignment (aa or nt) are included
	 * @throws IllegalAccessException 
	 * @throws InstantiationException 
	 */
	private static void prepareColourings() throws Exception {
		
		
		// Find all colour classes. Reflections are not working in cheerpj so adding classes manually
		
		//Reflections reflections = new Reflections("peachtree.aln.colourings");
		//Set<Class<? extends Colouring>> classes = reflections.getSubTypesOf(Colouring.class);
		colouringClasses = new ArrayList<>();
		colouringClasses.add(ClustalAminoColouring.class);
		colouringClasses.add(JalviewNucleotideColouring.class);
		
		
		List<Colouring> classes = new ArrayList<>();
		for (Class<? extends Colouring> colClass : colouringClasses) {
	        Colouring col = colClass.newInstance();
	        if (AlignmentAPI.colouringIsApplicable(col)) {
	        	 System.out.println(colClass.getName() + " is applicable");
	        	 classes.add(col);
	        }
	       
		}
		colourings = new DiscreteOption("colourings", "Alignment", "Colour scheme of the alignment", classes.get(0), classes);
	}
	
	
	
	/**
	 * Generate all objects. Now ready - to render onto the svg
	 * Return canvas width and height but do not return any of the objects until getGraphics is called
	 * @return
	 */
	public static String initGraphics() {
		
		
		if (!isReady()) return "{}";
		
		
		try {
		
			// Bounds
			double xdivide = ((NumericalOption)division).getVal();
			
			JSONObject json = new JSONObject();
			double width = ((NumericalOption)canvasWidth).getVal();
			double height = ((NumericalOption)canvasHeight).getVal();
			json.put(canvasWidth.getName(), width);
			json.put(canvasHeight.getName(), height);
			
			
			JSONArray objs = new JSONArray();
			
			// Alignment?
			if (AlignmentAPI.isReady()) {
				JSONArray alignment = AlignmentAPI.getGraphics(xdivide*width, width, 0, height);
				objs.putAll(alignment);
				
				json.put("nsites", AlignmentAPI.getNsites());
				json.put("nsitesdisplayed", AlignmentAPI.getNsitesDisplayed());
				json.put("ntaxa", AlignmentAPI.getNtaxa());
				
				
			}
			
			graphicalObjects = objs;
			
			System.out.println(json.toString());
			
			return json.toString();
		
		} catch (Exception e) {
			return getErrorJSON(e);
		}
		
	}
	
	
	/**
	 * Return the json objects generated by initGraphics 1 chunk at a time
	 * @return
	 */
	public static String getGraphics() {
		if (graphicalObjects == null || graphicalObjects.length() == 0) return new JSONArray().toString();
		

		
		// Keep adding to the string until the string is too large
		// TODO use a string builder for efficiency
		String out = "[";
		int len = 0;
		boolean addedObj = false;
		do {
			String str = graphicalObjects.get(0).toString();
			if (str.length() + len < CHUNK_SIZE) {
				
				//System.out.println("Added json at position " + i + ". Total length " + );
				
				// Update string
				if (addedObj) out = out + ",";
				addedObj = true;
				out = out + str;
				len = out.length();

				// Remove 1st element from from array
				graphicalObjects.remove(0);
				
			}else {
				
				// Chunk is too big. Move on.
				break;
			}
			
		}while(graphicalObjects.length() > 0);
		

		if (!addedObj) {
			System.out.println("Error: chunk sizes are too small");
		}

		out += "]";
		
		return out;
	}

	
	
	/**
	 * Get the list of visual settings as a json string
	 * @return
	 */
	public static String getOptions() {
		
		try {
			prepareColourings();
			
			
			// Introspectively find all options and add them to the list of options
			List<Option> options = new ArrayList<>();
			Field[] fields = OptionsAPI.class.getDeclaredFields();
			for (Field field: fields) {
				
				if (field.getType().equals(Option.class)) {
					try {
						Option option = (Option) field.get(null);
						options.add(option);
					} catch (Exception e) {
						e.printStackTrace();
					} 
				}
			}
			
			
			
			JSONArray arr = new JSONArray();
			for (Option option : options) {
				arr.put(option.toJSON());
			}
			return arr.toString();
			
		} catch(Exception e) {
			e.printStackTrace();
			return getErrorJSON(e);
		}
	}
	
	
	
	/**
	 * Gets a JSON string from an Exception
	 * @param e
	 * @return
	 */
	public static String getErrorJSON(Exception e) {
		JSONObject json = new JSONObject().put("err",  e.getMessage());  
		return json.toString();
	}
	
	
	/**
	 * Is the system ready to render?
	 * @return
	 */
	public static boolean isReady() {
		
		boolean ready = AlignmentAPI.isReady();
		return ready;
		
	}
	
	

}
