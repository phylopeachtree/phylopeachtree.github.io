package peachtree.options;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;

import org.json.JSONArray;
import org.json.JSONObject;

import peachtree.aln.AlignmentAPI;



public class OptionsAPI {
	
	static List<Option> options;
	
	static Option canvasWidth  = new NumericalOption("width", "general", "Width of canvas", 1000, 100, 2000);
	static Option canvasHeight  = new NumericalOption("height", "general", "Height of canvas", 700, 100, 2000);
	static Option division  = new NumericalOption("division", "general", "Relative position of the tree/alignment boundary", 0, 0, 1);
		
	
	static final long CHUNK_SIZE = 30000;
	static JSONArray graphicalObjects = null;
	
	public static void init() {
		
		graphicalObjects = null;
		
		// Introspectively find all options and add them to the list of options
		options = new ArrayList<>();
		Field[] fields = OptionsAPI.class.getDeclaredFields();
		for (Field field: fields) {
			
			
			if (field.getType().equals(Option.class)) {
				
				try {
					Option option = (Option) field.get(null);
					options.add(option);
				} catch (Exception e) {
					e.printStackTrace();
				} 
			}
		}
		
		
		
		
		
		
		
	}
	
	
	
	/**
	 * Generate all objects. Now ready - to render onto the svg
	 * Return canvas width and height but do not return any of the objects until getGraphics is called
	 * @return
	 */
	public static String initGraphics() {
		
		
		if (!isReady()) return "{}";
		
		
		try {
		
			// Bounds
			double xdivide = ((NumericalOption)division).getVal();
			
			JSONObject json = new JSONObject();
			double width = ((NumericalOption)canvasWidth).getVal();
			double height = ((NumericalOption)canvasHeight).getVal();
			json.put(canvasWidth.getName(), width);
			json.put(canvasHeight.getName(), height);
			
			
			JSONArray objs = new JSONArray();
			
			// Alignment?
			if (AlignmentAPI.isReady()) {
				JSONArray alignment = AlignmentAPI.getGraphics(xdivide*width, width, 0, height);
				objs.putAll(alignment);
			}
			
			graphicalObjects = objs;
			
			System.out.println(json.toString());
			
			return json.toString();
		
		} catch (Exception e) {
			return getErrorJSON(e);
		}
		
	}
	
	
	/**
	 * Return the json objects generated by initGraphics 1 chunk at a time
	 * @return
	 */
	public static String getGraphics() {
		if (graphicalObjects == null || graphicalObjects.length() == 0) return new JSONArray().toString();
		

		
		// Keep adding to the string until the string is too large
		// TODO use a string builder for efficiency
		String out = "[";
		int len = 0;
		boolean addedObj = false;
		do {
			String str = graphicalObjects.get(0).toString();
			if (str.length() + len < CHUNK_SIZE) {
				
				//System.out.println("Added json at position " + i + ". Total length " + );
				
				// Update string
				if (addedObj) out = out + ",";
				addedObj = true;
				out = out + str;
				len = out.length();

				// Remove 1st element from from array
				graphicalObjects.remove(0);
				
			}else {
				
				// Chunk is too big. Move on.
				break;
			}
			
		}while(graphicalObjects.length() > 0);
		

		if (!addedObj) {
			System.out.println("Error: chunk sizes are too small");
		}

		out += "]";
		
		return out;
	}

	
	
	/**
	 * Get the list of visual settings as a json string
	 * @return
	 */
	public static String getOptions() {
		
		JSONArray arr = new JSONArray();
		for (Option option : options) {
			arr.put(option.toJSON());
		}
		return arr.toString();
	}
	
	
	
	/**
	 * Gets a JSON string from an Exception
	 * @param e
	 * @return
	 */
	public static String getErrorJSON(Exception e) {
		JSONObject json = new JSONObject().put("err",  e.getMessage());  
		return json.toString();
	}
	
	
	/**
	 * Is the system ready to render?
	 * @return
	 */
	public static boolean isReady() {
		
		boolean ready = AlignmentAPI.isReady();
		return ready;
		
	}
	
	

}
